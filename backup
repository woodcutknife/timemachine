#!/bin/bash

# check config file
CONFIG_FILE="backup.conf"
if [ ! -e "$CONFIG_FILE" ]; then
    echo "config file not found. please check \`$CONFIG_FILE'."
    exit 78
fi
source $CONFIG_FILE


# check target
if [ -z "$TARGET" ] || [ -f "$TARGET" ]; then
    echo "target not specified or is a original file. please check it."
    exit 78
fi
[ -d "$TARGET" ] || mkdir "$TARGET"
if [ ! $? -eq 0 ]; then
    echo "cannot create target folder. maybe PERMISSION DENIED?"
    exit 78
fi


# check lock
if [ -f "$TARGET/lockfile" ]; then
    echo "lockfile exists. halt."
    exit 69
else
    touch "$TARGET/lockfile"
fi

mexit() {
    rm "$TARGET/lockfile"
    exit $1
}


# `backup status [file-or-folder]'
print_status() {
    while read path; do
        base=`basename "$path"`
        if [ "$1" = "$base" ]; then
            echo "$base [*] <= current (last sync)"
        else
            echo "$base"
        fi
    done
}

display_backup_status() {
    if [ -z "$1" ]; then
        backups=(${BACKUP//$DELIMITER/ })
    else
        backups=(${1//$DELIMITER/ })
    fi

    for backup in ${backups[@]}; do
        if [ -e $backup ]; then
            backup=`realpath $backup`
        else
            echo "$BASENAME: \`$backup' not found."
            continue
        fi

        backup_hash=`echo -n $backup | md5sum | cut -d' ' -f1`
        backup_target="$TARGET/$backup_hash"
        if [ -d "$backup_target" ]; then
            backup_cnt=`find "$backup_target" -maxdepth 1 -mindepth 1 -type d | wc -l`
            backup_current=`readlink "$backup_target/current"` 

            echo "===================================================="
            echo "BACKUP: $backup"
            echo "COUNT: $backup_cnt"
            echo "VERSIONS:"
            find "$backup_target" -maxdepth 1 -mindepth 1 -type d | sort -r | print_status `basename "$backup_current"`
            echo "===================================================="
        else
            echo "$BASENAME: \`$backup' not in backup control."
        fi
    done
}


# `backup push [file-or-folder]'
collect_single_ignore() {
    backup="$1"
    backup_base=`basename "$backup"`
    while read ignore_path; do
        relative_path=${ignore_path##"$backup/"}
        relative_dir=`dirname "$relative_path"`
        if [ "$relative_dir" == "." ]; then
            cat "$ignore_path" | xargs -I '{}' echo "$backup_base/{}"
        else
            cat "$ignore_path" | xargs -I '{}' echo "$relative_dir/$backup_base/{}"
        fi
    done
}

collect_ignores() {
    find "$1" -name ".backupignore" -type f | collect_single_ignore "$1" 
}

push_data() {
    if [ -z "$1" ]; then
        backups=(${BACKUP//$DELIMITER/ })
    else
        backups=(${1//$DELIMITER/ })
    fi

    for backup in ${backups[@]}; do
        if [ -e $backup ]; then
            backup=`realpath $backup`
        else
            echo "$BASENAME: \`$backup' not found."
            continue
        fi

        backup_hash="`echo -n $backup | md5sum | cut -d' ' -f1`"
        backup_target="$TARGET/$backup_hash"

        # create folders if necessary
        [ -f "$backup_target" ] && rm -rf "$backup_target"
        [ -d "$backup_target" ] || mkdir "$backup_target"
        [ -f "$backup_target/current" ] && rm -rf "$backup_target/current"
        [ -d "$backup_target/current" ] || mkdir "$backup_target/current"

        # get backup ignore
        backup_ignore="/tmp/backup_ignore_$$_$backup_hash.pig"
        [ -e $backup_ignore ] && rm -rf $backup_ignore
        collect_ignores "$backup" > $backup_ignore

        # rsync
        date=`date "+%Y-%m-%dT%H_%M_%S"`
        rsync \
            --archive \
            --xattrs \
            --human-readable \
            --delete \
            --progress \
            --link-dest="$backup_target/current" \
            --exclude-from=$backup_ignore \
            "$backup" \
            "$backup_target/$date-incomplete/"
        rm -rf $backup_ignore

        if [ $? -eq 0 ]; then
            # backup complete
            mv "$backup_target/$date-incomplete" "$backup_target/$date"
            rm -rf "$backup_target/current"
            ln -s "$backup_target/$date" "$backup_target/current"
            touch "$backup_target/$date"

            # delte old backups
            backup_cnt=`find "$backup_target" -maxdepth 1 -mindepth 1 -type d | wc -l`
            if [ $backup_cnt -gt $BACKUP_UPPER_LIMIT ]; then
                delete_cnt=$(($backup_cnt - $BACKUP_UPPER_LIMIT))
                find "$backup_target" -maxdepth 1 -mindepth 1 -type d | sort | head -${delete_cnt} | xargs rm -rf
            fi
        else
            echo "$BASENAME: something error with rsync. :("
        fi
    done
}


# `backup restore file-or-folder version'
restore_data() {
    # find backup in backups
    backup=`realpath "$1"`
    backup_hash=`echo -n $backup | md5sum | cut -d' ' -f1`
    backup_target="$TARGET/$backup_hash"
    if [ ! -d "$backup_target" ]; then
        echo "$BASENAME: no backups found. :("
        mexit 66
    fi

    # find specified version
    version=$2
    if [ ! -d "$backup_target/$version" ]; then
        echo "$BASENAME: version \`$version' not found. :("
        mexit 66
    fi

    # restore to local
    backup_base=`basename "$backup"`
    backup_dir=`dirname "$backup"`
    if [ -f "$backup_target/$version/$backup_base" ]; then
        if [ -d "$backup" ]; then
            echo "$BASENAME: folder and file with same name. please check you local files."
            mexit 74
        fi
        rsync \
            --archive \
            --xattrs \
            --human-readable \
            --delete \
            --progress \
            "$backup_target/$version/$backup_base" \
            "$backup"
        if [ ! $? -eq 0 ]; then
            echo "$BASENAME: something error with rsync. :("
            mexit 71
        fi
    else
        if [ -f "$backup" ]; then
            echo "$BASENAME: folder and file with same name. please check you local files."
            mexit 74
        fi
        [ -d "$backup" ] || mkdir "$backup"
        date=`date "+%Y-%m-%dT%H_%M_%S"`
        rsync \
            --archive \
            --xattrs \
            --human-readable \
            --delete \
            --progress \
            --link-dest="$backup_dir" \
            "$backup_target/$version/$backup_base" \
            "$backup_dir/$date-incomplete"
        if [ ! $? -eq 0 ]; then
            echo "$BASENAME: something error with rsync. :("
            mexit 71
        fi

        # restore complete
        rm -rf "$backup"
        mv "$backup_dir/$date-incomplete/$backup_base" "$backup"
        rm -rf "$backup_dir/$date-incomplete"
    fi

    # set current
    rm -rf "$backup_target/current"
    ln -s "$backup_target/$version" "$backup_target/current"
}


# handle parameters
BASENAME=`basename $0`

print_general_usage() {
    echo "$BASENAME is a file backup tool under linux."
    echo "usage: $BASENAME {config,status,push,restore,help}"
}

print_help_usage() {
    echo "$BASENAME covers some basic functions. to learn about \`func', just enter \`$BASENAME help func'."
    echo "usage: $BASENAME help {config,status,push,restore,help}"
}

print_config_usage() {
    echo "all the settings of $BASENAME is located in \`$CONFIG_FILE'."
    echo "check this file for more details."
}

print_status_usage() {
    echo "display the status of your backup. if nothing is specified, $BASENAME will display all data specified in config file."
    echo "usage: $BASENAME status [file-or-folder]"
}

print_push_usage() {
    echo "push the data to be backuped. if nothing is specified, $BASENAME will push all data specified in config file."
    echo "usage: $BASENAME push [file-or-folder]"
}

print_restore_usage() {
    echo "restore the data from backup. you need to specify the data and the version you want to fallback."
    echo "you can use \`$BASENAME status [file-or-folder]' to check available versions."
    echo "usage: $BASENAME restore file-or-folder version"
    echo "example: $BASENAME restore ./test.sh 2014-05-25T15_13_18"
}

if [ $# -lt 1 ]; then
    print_general_usage
    mexit 64
fi

case $1 in
    help) 
        if [ $# -gt 1 ]; then
            case $2 in
                help) 
                    print_help_usage ; mexit 0 ;;
                config) 
                    print_config_usage ; mexit 0 ;;
                status)
                    print_status_usage ; mexit 0 ;;
                push)
                    print_push_usage ; mexit 0 ;;
                restore)
                    print_restore_usage ; mexit 0 ;;
            esac
        else
            print_help_usage ; mexit 64
        fi ;
        mexit 0 ;;
    config)
        print_config_usage ;
        mexit 0 ;;
    status)
        display_backup_status "$2" ;
        mexit 0 ;;
    push)
        push_data "$2" ;
        mexit 0 ;;
    restore)
        if [ $# -lt 3 ]; then
            print_restore_usage
            mexit 64
        else
            restore_data "$2" $3
        fi ;
        mexit 0 ;;
    *)
        print_general_usage; 
        mexit 64 ;;
esac
